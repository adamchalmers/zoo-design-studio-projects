n = 4 // number of rows/columns
width = 1 // width of one square
gap = width * 0.5 // gap between squares
spacing = width + gap // amount to shift each square over
height = 10
baseHeight = 1

// total width of the entire shape, across all squares
totalWidth = n * width + (n - 1) * gap

fn square(length, at, offset) {
  return startSketchOn(offsetPlane(XY, offset))
    |> startProfile(at = [
         at[0] - (totalWidth / 2),
         at[1] - (totalWidth / 2)
       ])
    |> xLine(length)
    |> yLine(length)
    |> xLine(length = -length)
    |> yLine(length = -length)
    |> close()
}

fn colorFor(row, column) {
  r = 10 + row * 10
  b = 10 + column * 10
  g = 40
  return appearance::hexString([r, g, b])
}

// Custom rotation function for easing in/out.
// Basically, this is smaller at the top/bottom of each tube, and bigger in the middle.
fn ease(@t) {
  return if t < 0.5 {
    8 * pow(t, exp = 4)
  } else {
    1 - (8 * pow(1 - t, exp = 4))
  }
}

// This is a *weight* (twist density), not a 0..1 easing curve.
// Near 0 at both ends, peaked in the middle.
fn twistWeight(@t) {
  return if t < 0.5 {
    32 * pow(t, exp = 3)
  } else {
    32 * pow(1 - t, exp = 3)
  }
}

// Discrete cumulative integral of twistWeight() over [0,1] using 'samples' steps.
// Returns normalized partial sum up to index i, so result is in [0,1].
fn integratedEase(@i, samples) {
  indices = [0 ..< samples]

  values = map(indices, f = fn(@j) {
    t = j / (samples - 1)
    return twistWeight(t)
  })

  partial = reduce(indices, initial = 0, f = fn(@j, accum) {
    return if j <= i { accum + values[j] } else { accum }
  })

  total = reduce(values, initial = 0, f = fn(@v, accum) {
    return accum + v
  })

  return partial / total
}

fn tube(@cellNum) {
  row = rem(cellNum, divisor = n)
  column = floor(cellNum / n)

  samples = 20

  // Sketch a cross-section of the tube.
  // 'i' determines how high up the tube we're sampling, which affects its rotation.
  fn tubeSample(@i) {
    theta = 90deg * integratedEase(i, samples)
    sq = square(length = width, at = [row * spacing, column * spacing], offset = height / samples * i)
    return sq
      |> rotate(axis = Z, angle = theta, global = true)
  }

  return [0..<samples]
    |> map(f = tubeSample)
    |> loft()
    |> appearance(color = colorFor(row, column))
}

tubes = map([0 ..< n * n], f = tube)
base = square(length = totalWidth, at = [0, 0], offset = -baseHeight)
  |> extrude(length = baseHeight)
