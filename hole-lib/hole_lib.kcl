// Tops


import cross, angleAxis, matrixRotate from "vectors.kcl"

holeTypeSimple = 0
holeTypeCounterbore = 1
holeTypeCountersink = 2

export fn simple() {
  return { feature = holeTypeSimple }
}

export fn counterbore(diameter, depth) {
  return {
    diameter = diameter,
    depth = depth,
    feature = holeTypeCounterbore
  }
}

export fn countersink(diameter, angle) {
  return {
    diameter = diameter,
    angle = angle,
    feature = holeTypeCountersink
  }
}

// Bodies


export fn blind(depth, diameter) {
  return {
    blindDepth = depth,
    diameter = diameter
  }
}

// Ends


export fn drill(pointAngle) {
  return { drillBitAngle = pointAngle }
}

export fn flat() {
  return { drillBitAngle = 179.99deg }
}

// Defining the hole


fn drawTop(@partialHoleProfile, body, holeType) {
  prof = if holeType.feature == holeTypeSimple {
    partialHoleProfile
      |> yLine(length = body.diameter)
  } else if holeType.feature == holeTypeCounterbore {
    lip = (holeType.diameter - body.diameter) / 2
    partialHoleProfile
      |> xLine(length = holeType.depth)
      |> yLine(length = holeType.diameter / 2)
      |> xLine(length = -holeType.depth)
      |> yLine(length = -lip)
  } else if holeType.feature == holeTypeCountersink {
    t = holeType.angle / 2
    tr = holeType.diameter / 2
    br = body.diameter / 2
    assert(tr, isGreaterThan = br, error = "Diameter of the countersink must be greater than diameter of the hole's body")
    // Ugly trigonometry that I calculated with pen and paper
    up = (tr - br) / tan(t)
    b = br / tan(t)
    diag = (up + b) / cos(t) - (2 / (tan(t) * cos(t)))
    alpha = 90 - t
    partialHoleProfile
      |> xLine(length = up)
      |> yLine(length = tr)
      |> angledLine(length = diag, angle = 270 - alpha)
  } else {
    assert(holeType.feature, isLessThanOrEqual = holeTypeCountersink, error = "unknown holeType feature")
  }
  return prof
}

fn holeTypeHeight(body, holeType) {
  height = if holeType.feature == holeTypeSimple {
    0
  } else if holeType.feature == holeTypeCounterbore {
    holeType.depth
  } else if holeType.feature == holeTypeCountersink {
    t = holeType.angle / 2
    tr = holeType.diameter / 2
    br = body.diameter / 2
    // Ugly trigonometry that I calculated with pen and paper
    up = (tr - br) / tan(t)
up
  } else {
    assert(holeType.feature, isLessThanOrEqual = holeTypeCountersink, error = "unknown holeType feature")
  }
  return height
}

// Actually defining a hole

// v2 is the X axis by convention, but cannot coerce properly
// so must give it manually.
conventionalAxisV2 = [1, 0, 0]
conventionalAxis = X
conventionalPlane = XY

export fn holeProfile(bottom, body, holeType) {
  // Calculate the drill bit height
  radius = body.diameter / 2
  theta = bottom.drillBitAngle / 2
  drillHeight = radius / tan(theta)

  // Calculate total model height from holeType to bottom
  hBody = body.blindDepth
  hBott = drillHeight
  totalHeight = hBody + hBott + holeTypeHeight(body, holeType)
  return startSketchOn(conventionalPlane)
    |> startProfile(at = [-totalHeight, 0])
    // Drill profile
    |> xLine(length = drillHeight)
    // Body depth
    |> xLine(length = body.blindDepth)
    // Top
    |> drawTop(body, holeType)
    // Body depth
    |> xLine(length = -body.blindDepth)
    // // Drill profile
    |> line(endAbsolute = [profileStartX(%), profileStartY(%)])
    |> close()
}

export fn revolveHole(@holeProfile) {
  return holeProfile
    |> revolve(axis = conventionalAxis)
    |> appearance(color = "#ff0000")
}

fn rotateToFace(solid, face) {
  targetPlane = planeOf(solid, face)
  targetPlaneNormal = vector::cross(targetPlane.xAxis, v = targetPlane.yAxis)

  tn = cross(v1 = conventionalAxisV2, v2 = targetPlaneNormal)
  targetNormal = [
    tn[0]: number(mm),
    tn[1]: number(mm),
    tn[2]: number(mm)
  ]: Point3d
  dotProd = vector::dot(vector::normalize(targetPlaneNormal), v =   vector::normalize(conventionalAxisV2)): number(_)
  rot = if vector::magnitude(targetNormal) == 0 {
    if acos(dotProd) == 180deg {
      { axis = [0, 1, 0], angle = 180deg }
    } else {
      { axis = [1, 0, 0], angle = 0 }
    }
  } else {
    {
      axis = targetNormal,
      angle = acos(dotProd)
    }
  }
  return rot
}

export fn hole(@solid, face, hole, cutAt) {
  targetPlane = planeOf(solid, face)
  rot = rotateToFace(solid, face)

  toCut = hole
    |> revolveHole()
    |> translate(x = targetPlane.origin[0], y = targetPlane.origin[1], z = targetPlane.origin[2])
    |> rotate(axis = rot.axis, angle = rot.angle)
    // This translate is y and z because the hole is sketched along the x axis of the plane
    |> translate(y = cutAt[0], z = cutAt[1], global = false)
  return subtract(solid, tools = [toCut])
  // return solid
}

export fn holes(@solid, face, holeProfiles, cutAt) {
  rot = rotateToFace(solid, face, cutAt)
  mag = magnitude(rot.translateDist)
  x = (rot.targetPlaneNormal[0] * mag): number(mm)
  y = (rot.targetPlaneNormal[1] * mag): number(mm)
  z = (rot.targetPlaneNormal[2] * mag): number(mm)
  ts = 1
  toCut = holeProfiles
    |> map(f = fn(@holeProfile) {
      return revolveHole(holeProfile)
        // Translate to the origin of the plane
        |> translate(x = x * ts, y = y * ts, z = z * ts)
        |> rotate(axis = rot.axis, angle = rot.angle)
    })
  // return subtract(solid, tools = toCut)
  return solid
}

cubeLen = 9
bigCube = startSketchOn(XY)
  |> startProfile(at = [-cubeLen / 2, -cubeLen / 2 + 10])
  |> line(end = [cubeLen, 0], tag = $a)
  |> line(end = [0, cubeLen], tag = $b)
  |> line(end = [-cubeLen, 0], tag = $c)
  |> line(end = [0, -cubeLen], tag = $d)
  |> close()
  |> extrude(length = cubeLen, symmetric = true)
  |> translate(x = 5)
  |> rotate(axis = [1, 1, 0], angle = 45, global = true)
  |> hole(face = a, cutAt = [1, 1], hole = holeProfile(bottom = flat(), body = blind(depth = 4, diameter = 4), holeType = countersink(diameter = 5, angle = 88deg)))

bigCube2 = startSketchOn(XY)
  |> startProfile(at = [-cubeLen / 2, -cubeLen / 2])
  |> line(end = [cubeLen, 0], tag = $a2)
  |> line(end = [0, cubeLen], tag = $b2)
  |> line(end = [-cubeLen, 0], tag = $c2)
  |> line(end = [0, -cubeLen], tag = $d2)
  |> close()
  |> extrude(length = cubeLen, symmetric = true)
  |> hole(face = a2, hole = holeProfile(bottom = flat(), body = blind(depth = 2, diameter = 4), holeType = counterbore(diameter = 5, depth = 1)), cutAt = [0, 0])
